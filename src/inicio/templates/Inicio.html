import matplotlib.pyplot as plt
import random
import timeit


# Bubble Sort
def bubble_sort(lista):
    n = len(lista)
    for i in range(n):
        for j in range(n - i - 1):
            if lista[j] > lista[j + 1]:
                lista[j], lista[j + 1] = lista[j + 1], lista[j]


# Selection Sort
def selection_sort(lista):
    n = len(lista)
    for i in range(n):
        min_index = i
        for j in range(i + 1, n):
            if lista[j] < lista[min_index]:
                min_index = j
        lista[i], lista[min_index] = lista[min_index], lista[i]


# Insertion Sort
def insertion_sort(lista):
    n = len(lista)
    for i in range(1, n):
        chave = lista[i]
        j = i - 1
        while j >= 0 and lista[j] > chave:
            lista[j + 1] = lista[j]
            j -= 1
        lista[j + 1] = chave


# Merge Sort
def merge_sort(lista):
    if len(lista) > 1:
        meio = len(lista) // 2
        esquerda = lista[:meio]
        direita = lista[meio:]

        merge_sort(esquerda)
        merge_sort(direita)

        i = j = k = 0

        while i < len(esquerda) and j < len(direita):
            if esquerda[i] < direita[j]:
                lista[k] = esquerda[i]
                i += 1
            else:
                lista[k] = direita[j]
                j += 1
            k += 1

        while i < len(esquerda):
            lista[k] = esquerda[i]
            i += 1
            k += 1

        while j < len(direita):
            lista[k] = direita[j]
            j += 1
            k += 1


# Quick Sort
def quick_sort(lista):
    if len(lista) <= 1:
        return lista
    else:
        pivo = lista[0]
        menores = [x for x in lista[1:] if x <= pivo]
        maiores = [x for x in lista[1:] if x > pivo]
        return quick_sort(menores) + [pivo] + quick_sort(maiores)


# Heap Sort
def heapify(lista, n, i):
    maior = i
    esquerda = 2 * i + 1
    direita = 2 * i + 2

    if esquerda < n and lista[i] < lista[esquerda]:
        maior = esquerda

    if direita < n and lista[maior] < lista[direita]:
        maior = direita

    if maior != i:
        lista[i], lista[maior] = lista[maior], lista[i]
        heapify(lista, n, maior)


def heap_sort(lista):
    n = len(lista)

    for i in range(n // 2 - 1, -1, -1):
        heapify(lista, n, i)

    for i in range(n - 1, 0, -1):
        lista[i], lista[0] = lista[0], lista[i]
        heapify(lista, i, 0)


# Shell Sort
def shell_sort(lista):
    n = len(lista)
    gap = n // 2

    while gap > 0:
        for i in range(gap, n):
            temp = lista[i]
            j = i
            while j >= gap and lista[j - gap] > temp:
                lista[j] = lista[j - gap]
                j -= gap
            lista[j] = temp
        gap //= 2


# Counting Sort
def counting_sort(lista):
    max_valor = max(lista) + 1
    count = [0] * max_valor

    for num in lista:
        count[num] += 1

    i = 0
    for j in range(max_valor):
        while count[j] > 0:
            lista[i] = j
            i += 1
            count[j] -= 1


# Radix Sort
def counting_sort_exp(lista, exp):
    n = len(lista)
    count = [0] * 10
    output = [0] * n

    for num in lista:
        index = (num // exp) % 10
        count[index] += 1

    for i in range(1, 10):
        count[i] += count[i - 1]

    i = n - 1
    while i >= 0:
        num = lista[i]
        index = (num // exp) % 10
        output[count[index] - 1] = num
        count[index] -= 1
        i -= 1

    for i in range(n):
        lista[i] = output[i]


def radix_sort(lista):
    max_valor = max(lista)
    exp = 1

    while max_valor // exp > 0:
        counting_sort_exp(lista, exp)
        exp *= 10


# Bucket Sort
def bucket_sort(lista):
    n = len(lista)
    buckets = [[] for _ in range(n)]

    for num in lista:
        index = int(num * n)
        buckets[index].append(num)

    for i in range(n):
        insertion_sort(buckets[i])

    k = 0
    for i in range(n):
        for j in range(len(buckets[i])):
            lista[k] = buckets[i][j]
            k += 1


# Função para gerar uma lista de inteiros de modo aleatório
def geraLista(tam):
    random.seed()
    i = 0
    lista = []
    while i < tam:
        lista.append(random.randint(1, tam))
        i += 1

    return lista


# Execução dos algoritmos de ordenação para diferentes tamanhos
algoritmos = [("Bubble Sort", bubble_sort), ("Selection Sort", selection_sort),
              ("Insertion Sort", insertion_sort), ("Merge Sort", merge_sort),
              ("Quick Sort", quick_sort), ("Heap Sort", heap_sort),
              ("Shell Sort", shell_sort), ("Counting Sort", counting_sort),
              ("Radix Sort", radix_sort), ("Bucket Sort", bucket_sort)]

tamanhos = [1000, 3000, 6000, 9000, 12000, 15000, 18000, 21000, 24000]
tempos = [[] for _ in range(len(algoritmos))]

for tamanho in tamanhos:
    lista = geraLista(tamanho)
    for i, (_, algoritmo) in enumerate(algoritmos):
        lista_teste = list(lista)
        tempo = timeit.timeit(lambda: algoritmo(lista_teste), number=1)
        tempos[i].append(tempo)
    print("Lista de tamanho", tamanho, "ordenada")

fig, ax = plt.subplots()
for i, (nome, _) in enumerate(algoritmos):
    ax.plot(tamanhos, tempos[i], label=nome)

ax.set_ylabel("TEMPO")
ax.set_xlabel("TAMANHO")

legend = ax.legend(loc='upper center', shadow=True)
frame = legend.get_frame()
frame.set_facecolor('0.90')

for label in legend.get_texts():
    label.set_fontsize('large')

for label in legend.get_lines():
    label.set_linewidth(1.5)

plt.show()
